# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_shell.ipynb.

# %% ../nbs/02_shell.ipynb 2
from __future__ import annotations

import os
os.environ['MPLBACKEND'] = 'module://matplotlib_inline.backend_inline'

from fastcore.imports import *
from fastcore.basics import *
from fastcore.script import call_parse

import multiprocessing
try:
    if sys.platform == 'darwin': multiprocessing.set_start_method("fork")
except RuntimeError: pass # if re-running cell

import tokenize
from IPython.core.interactiveshell import InteractiveShell
from IPython.core.displayhook import DisplayHook
from IPython.core.displaypub import DisplayPublisher
from base64 import b64encode
from io import StringIO

from .fastshell import FastInteractiveShell
from .nbio import *
from .nbio import _dict2obj

from collections.abc import Callable

# %% auto 0
__all__ = ['CaptureShell', 'find_output', 'out_exec', 'out_stream', 'out_error', 'exec_nb']

# %% ../nbs/02_shell.ipynb 4
# IPython requires a DisplayHook and DisplayPublisher
# We override `__call__` and `publish` to save outputs instead of printing them
class _CaptureHook(DisplayHook):
    "Called when displaying a result"

    def quiet(self):
        "Should we silence because of ';'?"
        sio = StringIO(self.shell._code)
        tokens = list(tokenize.generate_tokens(sio.readline))
        for t in reversed(tokens):
            if t.type in (tokenize.ENDMARKER, tokenize.NL, tokenize.NEWLINE, tokenize.COMMENT): continue
            return t.type == tokenize.OP and t.string == ';'

    def __call__(self, result=None):
        if result is None or self.quiet(): return
        self.fill_exec_result(result)
        self.shell._result(result)

class _CapturePub(DisplayPublisher):
    "Called when adding an output"
    def publish(self, data, metadata=None, **kwargs): self.shell._add_out(data, metadata, typ='display_data')

# %% ../nbs/02_shell.ipynb 5
# These are the standard notebook formats for exception and stream data (e.g stdout)
def _out_exc(ename, evalue, traceback): return dict(ename=str(ename), evalue=str(evalue), output_type='error', traceback=traceback)
def _out_stream(text, name): return dict(name=name, output_type='stream', text=text.splitlines(True))

# %% ../nbs/02_shell.ipynb 6
def _format_mimedata(k, v):
    "Format mime-type keyed data consistently with Jupyter"
    if k.startswith('text/'): return v.splitlines(True)
    if k.startswith('image/') and isinstance(v, bytes):
        v = b64encode(v).decode()
        return v+'\n' if not v.endswith('\n') else v
    return v

# %% ../nbs/02_shell.ipynb 8
class CaptureShell(FastInteractiveShell):
    "Execute the IPython/Jupyter source code"
    def __init__(self,
                 path:str|Path=None): # Add `path` to python path
        super().__init__(displayhook_class=_CaptureHook, display_pub_class=_CapturePub)
        InteractiveShell._instance = self
        self.out,self.count = [],1
        self.exc = self.result = self._fname = self._cell_idx = self._stdout = self._stderr = None
        if IN_NOTEBOOK:
            try: self.enable_matplotlib('inline')
            except ModuleNotFoundError: pass
        if path: self.set_path(path)

    def enable_matplotlib(self, gui=None):
        "Enable `matplotlib` in a nested shell"
        from matplotlib_inline.backend_inline import configure_inline_support
        configure_inline_support.current_backend = 'unset'
        return super().enable_matplotlib(gui)
    
    def set_path(self, path):
        "Add `path` to python path, or `path.parent` if it's a file"
        path = Path(path)
        if path.is_file(): path = path.parent
        self.run_cell(f"import sys; sys.path.insert(0, '{path.as_posix()}')")

    def enable_gui(self, gui=None):
        "Disable GUI (over-ridden; called by IPython)"
        pass
    
    def _showtraceback(self, etype, evalue, stb: str):
        self.out.append(_out_exc(etype, evalue, stb))
        self.exc = (etype, evalue, '\n'.join(stb))

    def _add_out(self, data, meta, typ='execute_result', **kwargs):
        self._stream()
        fd = {k:_format_mimedata(k,v) for k,v in data.items()}
        self.out.append(dict(data=fd, metadata=meta, output_type=typ, **kwargs))

    def _add_exec(self, result, meta, typ='execute_result'):
        self._add_out(result, meta, execution_count=self.count)
        self.count += 1

    def _result(self, result):
        self.result = result
        self._add_exec(*self.display_formatter.format(result))

    def _stream(self):
        for nm in ('stdout','stderr'):
            attr = '_'+nm
            std = getattr(self, attr)
            if std is not None:
                text = std.getvalue()
                if text:
                    self.out.append(_out_stream(text, nm))
                    setattr(self, attr, StringIO())

# %% ../nbs/02_shell.ipynb 11
@patch
def run(self:CaptureShell,
        code:str, # Python/IPython code to run
        stdout=True, # Capture stdout and save as output?
        stderr=True): # Capture stderr and save as output?
    "Run `code`, returning a list of all outputs in Jupyter notebook format"
    self._code = code
    self.exc = False
    self.out.clear()
    sys_stdout,sys_stderr = sys.stdout,sys.stderr
    if stdout: self._stdout = sys.stdout = StringIO()
    if stderr: self._stderr = sys.stderr = StringIO()
    try: self.run_cell(code)
    finally: sys.stdout,sys.stderr = sys_stdout,sys_stderr
    self._stream()
    return [*self.out]

# %% ../nbs/02_shell.ipynb 24
@patch
def cell(self:CaptureShell, cell, stdout=True, stderr=True):
    "Run `cell`, skipping if not code, and store outputs back in cell"
    if cell.cell_type!='code': return
    self._cell_idx = cell.idx_ + 1
    outs = self.run(cell.source)
    if outs:
        cell.outputs = _dict2obj(outs)
        for o in outs:
            if 'execution_count' in o: cell['execution_count'] = o['execution_count']

# %% ../nbs/02_shell.ipynb 27
def find_output(outp, # Output from `run`
                ot='execute_result' # Output_type to find
               ):
    "Find first output of type `ot` in `CaptureShell.run` output"
    return first(o for o in outp if o['output_type']==ot)

# %% ../nbs/02_shell.ipynb 30
def out_exec(outp):
    "Get data from execution result in `outp`."
    out = find_output(outp)
    if out: return '\n'.join(first(out['data'].values()))

# %% ../nbs/02_shell.ipynb 32
def out_stream(outp):
    "Get text from stream in `outp`."
    out = find_output(outp, 'stream')
    if out: return ('\n'.join(out['text'])).strip()

# %% ../nbs/02_shell.ipynb 34
def out_error(outp):
    "Get traceback from error in `outp`."
    out = find_output(outp, 'error')
    if out: return '\n'.join(out['traceback'])

# %% ../nbs/02_shell.ipynb 37
def _false(o): return False

@patch
def run_all(self:CaptureShell,
            nb, # A notebook read with `nbclient` or `read_nb`
            exc_stop:bool=False, # Stop on exceptions?
            preproc:Callable=_false, # Called before each cell is executed
            postproc:Callable=_false, # Called after each cell is executed
            inject_code:str|None=None, # Code to inject into a cell
            inject_idx:int=0 # Cell to replace with `inject_code`
           ):
    "Run all cells in `nb`, stopping at first exception if `exc_stop`"
    if inject_code is not None: nb.cells[inject_idx].source = inject_code
    for cell in nb.cells:
        if not preproc(cell):
            self.cell(cell)
            postproc(cell)
        if self.exc and exc_stop: raise self.exc[1] from None

# %% ../nbs/02_shell.ipynb 51
@patch
def execute(self:CaptureShell,
            src:str|Path, # Notebook path to read from
            dest:str|None=None, # Notebook path to write to
            exc_stop:bool=False, # Stop on exceptions?
            preproc:Callable=_false, # Called before each cell is executed
            postproc:Callable=_false, # Called after each cell is executed
            inject_code:str|None=None, # Code to inject into a cell
            inject_path:str|Path|None=None, # Path to file containing code to inject into a cell
            inject_idx:int=0 # Cell to replace with `inject_code`
):
    "Execute notebook from `src` and save with outputs to `dest"
    nb = read_nb(src)
    self._fname = src
    self.set_path(Path(src).parent.resolve())
    if inject_path is not None: inject_code = Path(inject_path).read_text()
    self.run_all(nb, exc_stop=exc_stop, preproc=preproc, postproc=postproc,
                 inject_code=inject_code, inject_idx=inject_idx)
    if dest: write_nb(nb, dest)

# %% ../nbs/02_shell.ipynb 55
@patch
def prettytb(self:CaptureShell, 
             fname:str|Path=None): # filename to print alongside the traceback
    "Show a pretty traceback for notebooks, optionally printing `fname`."
    fname = fname if fname else self._fname
    _fence = '='*75
    cell_intro_str = f"While Executing Cell #{self._cell_idx}:" if self._cell_idx else "While Executing:"
    cell_str = f"\n{cell_intro_str}\n{self.exc[-1]}"
    fname_str = f' in {fname}' if fname else ''
    return f"{type(self.exc[1]).__name__}{fname_str}:\n{_fence}\n{cell_str}\n"

# %% ../nbs/02_shell.ipynb 74
@call_parse
def exec_nb(
    src:str, # Notebook path to read from
    dest:str='', # Notebook path to write to
    exc_stop:bool=False, # Stop on exceptions?
    inject_code:str=None, # Code to inject into a cell
    inject_path:str=None, # Path to file containing code to inject into a cell
    inject_idx:int=0 # Cell to replace with `inject_code`
):
    "Execute notebook from `src` and save with outputs to `dest`"
    CaptureShell().execute(src, dest, exc_stop=exc_stop, inject_code=inject_code,
                           inject_path=inject_path, inject_idx=inject_idx)
